{"version":3,"file":"DataFrameJSON.js","sources":["../../../src/dataframe/DataFrameJSON.ts"],"sourcesContent":["import { DataFrame, FieldType, FieldConfig, Labels, QueryResultMeta, Field } from '../types';\n\nimport { guessFieldTypeFromNameAndValue } from './processDataFrame';\n\n/**\n * The JSON transfer object for DataFrames.  Values are stored in simple JSON\n *\n * @alpha\n */\nexport interface DataFrameJSON {\n  /**\n   * The schema defines the field type and configuration.\n   */\n  schema?: DataFrameSchema;\n\n  /**\n   * The field data\n   */\n  data?: DataFrameData;\n}\n\ntype FieldValues = unknown[];\n\n/**\n * @alpha\n */\nexport interface DataFrameData {\n  /**\n   * A columnar store that matches fields defined by schema.\n   */\n  values: FieldValues[];\n\n  /**\n   * Since JSON cannot encode NaN, Inf, -Inf, and undefined, these entities\n   * are decoded after JSON.parse() using this struct\n   */\n  entities?: Array<FieldValueEntityLookup | null>;\n\n  /**\n   * Holds value bases per field so we can encode numbers from fixed points\n   * e.g. [1612900958, 1612900959, 1612900960] -> 1612900958 + [0, 1, 2]\n   */\n  bases?: number[];\n\n  /**\n   * Holds value multipliers per field so we can encode large numbers concisely\n   * e.g. [4900000000, 35000000000] -> 1e9 + [4.9, 35]\n   */\n  factors?: number[];\n\n  /**\n   * Holds enums per field so we can encode recurring string values as ints\n   * e.g. [\"foo\", \"foo\", \"baz\", \"foo\"] -> [\"foo\", \"baz\"] + [0,0,1,0]\n   *\n   * NOTE: currently only decoding is implemented\n   */\n  enums?: Array<string[] | null>;\n\n  /**\n   * Holds integers between 0 and 999999, used by time-fields\n   * to store the nanosecond-precision that cannot be represented\n   * by the millisecond-based base value.\n   */\n  nanos?: Array<number[] | null>;\n}\n\n/**\n * The JSON transfer object for DataFrames.  Values are stored in simple JSON\n *\n * @alpha\n */\nexport interface DataFrameSchema {\n  /**\n   * Matches the query target refId\n   */\n  refId?: string;\n\n  /**\n   * Initial response global metadata\n   */\n  meta?: QueryResultMeta;\n\n  /**\n   * Frame name\n   */\n  name?: string;\n\n  /**\n   * Field definition without any metadata\n   */\n  fields: FieldSchema[];\n}\n\n/**\n * Field object passed over JSON\n *\n * @alpha\n */\nexport interface FieldSchema {\n  name: string; // The column name\n  type?: FieldType;\n  config?: FieldConfig;\n  labels?: Labels;\n}\n\n/**\n * Since JSON cannot encode NaN, Inf, -Inf, and undefined, the locations\n * of these entities in field value arrays are stored here for restoration\n * after JSON.parse()\n *\n * @alpha\n */\nexport interface FieldValueEntityLookup {\n  NaN?: number[];\n  Undef?: number[]; // Missing because of absence or join\n  Inf?: number[];\n  NegInf?: number[];\n}\n\nconst ENTITY_MAP: Record<keyof FieldValueEntityLookup, number | undefined> = {\n  Inf: Infinity,\n  NegInf: -Infinity,\n  Undef: undefined,\n  NaN: NaN,\n};\n\n/**\n * @internal use locally\n */\nexport function decodeFieldValueEntities(lookup: FieldValueEntityLookup, values: FieldValues) {\n  for (const key in lookup) {\n    const repl = ENTITY_MAP[key as keyof FieldValueEntityLookup];\n    for (const idx of lookup[key as keyof FieldValueEntityLookup]!) {\n      if (idx < values.length) {\n        values[idx] = repl;\n      }\n    }\n  }\n}\n\n/**\n * @internal use locally\n */\nexport function decodeFieldValueEnums(lookup: string[], values: FieldValues) {\n  for (let i = 0; i < values.length; i++) {\n    values[i] = lookup[Number(values[i])];\n  }\n}\n\nfunction guessFieldType(name: string, values: FieldValues): FieldType {\n  for (const v of values) {\n    if (v != null) {\n      return guessFieldTypeFromNameAndValue(name, v);\n    }\n  }\n  return FieldType.other;\n}\n\n/**\n * NOTE: dto.data.values will be mutated and decoded/inflated using entities,bases,factors,enums\n *\n * @alpha\n */\nexport function dataFrameFromJSON(dto: DataFrameJSON): DataFrame {\n  const { schema, data } = dto;\n\n  if (!schema || !schema.fields) {\n    throw new Error('JSON needs a fields definition');\n  }\n\n  // Find the longest field length\n  const length = data ? data.values.reduce((max, vals) => Math.max(max, vals.length), 0) : 0;\n  const fields = schema.fields.map((f, index) => {\n    let buffer = data ? data.values[index] : [];\n    let origLen = buffer.length;\n    let type = f.type;\n\n    if (origLen !== length) {\n      buffer.length = length;\n      // avoid sparse arrays\n      buffer.fill(undefined, origLen);\n    }\n\n    let entities = data?.entities?.[index];\n\n    if (entities) {\n      decodeFieldValueEntities(entities, buffer);\n    }\n\n    let enums = data?.enums?.[index];\n\n    if (enums) {\n      decodeFieldValueEnums(enums, buffer);\n      type = FieldType.string;\n    }\n\n    const nanos = data?.nanos?.[index];\n\n    // TODO: expand arrays further using bases,factors\n\n    const dataFrameField: Field & { entities: FieldValueEntityLookup } = {\n      ...f,\n      type: type ?? guessFieldType(f.name, buffer),\n      config: f.config ?? {},\n      values: buffer,\n      // the presence of this prop is an optimization signal & lookup for consumers\n      entities: entities ?? {},\n    };\n\n    if (nanos != null) {\n      dataFrameField.nanos = nanos;\n    }\n\n    return dataFrameField;\n  });\n\n  return {\n    ...schema,\n    fields,\n    length,\n  };\n}\n\n/**\n * This converts DataFrame to a json representation with distinct schema+data\n *\n * @alpha\n */\nexport function dataFrameToJSON(frame: DataFrame): DataFrameJSON {\n  const data: DataFrameData = {\n    values: [],\n  };\n\n  const allNanos: Array<number[] | null> = [];\n  let hasNanos = false;\n\n  const schema: DataFrameSchema = {\n    refId: frame.refId,\n    meta: frame.meta,\n    name: frame.name,\n    fields: frame.fields.map((f) => {\n      const { values, nanos, state, display, ...sfield } = f;\n      if ('entities' in sfield) {\n        delete sfield.entities;\n      }\n      data.values.push(values);\n\n      if (nanos != null) {\n        allNanos.push(nanos);\n        hasNanos = true;\n      } else {\n        allNanos.push(null);\n      }\n\n      return sfield;\n    }),\n  };\n\n  if (hasNanos) {\n    data.nanos = allNanos;\n  }\n\n  return {\n    schema,\n    data,\n  };\n}\n"],"names":[],"mappings":"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"}