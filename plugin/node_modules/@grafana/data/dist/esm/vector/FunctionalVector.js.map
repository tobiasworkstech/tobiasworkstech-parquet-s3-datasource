{"version":3,"file":"FunctionalVector.js","sources":["../../../src/vector/FunctionalVector.ts"],"sourcesContent":["import { Vector } from '../types';\n\nimport { vectorToArray } from './vectorToArray';\n\n/**\n * @public\n * @deprecated use a simple Arrays\n */\nexport abstract class FunctionalVector<T = any> implements Vector<T> {\n  abstract get length(): number;\n\n  abstract get(index: number): T;\n\n  // Implement \"iterator protocol\"\n  *iterator() {\n    for (let i = 0; i < this.length; i++) {\n      yield this.get(i);\n    }\n  }\n\n  set(index: number, value: T): void {\n    throw 'unsupported operation';\n  }\n\n  add(value: T): void {\n    throw 'unsupported operation';\n  }\n\n  push(...vals: T[]): number {\n    for (const v of vals) {\n      this.add(v);\n    }\n    return this.length;\n  }\n\n  // Implement \"iterable protocol\"\n  [Symbol.iterator]() {\n    return this.iterator();\n  }\n\n  forEach(iterator: (row: T, index: number, array: T[]) => void): void {\n    return vectorator(this).forEach(iterator);\n  }\n\n  map<V>(transform: (item: T, index: number, array: T[]) => V): V[] {\n    return vectorator(this).map(transform);\n  }\n\n  filter(predicate: (item: T, index: number, array: T[]) => boolean): T[] {\n    return vectorator(this).filter(predicate);\n  }\n\n  at(index: number): T | undefined {\n    return this.get(index);\n  }\n\n  toArray(): T[] {\n    return vectorToArray(this);\n  }\n\n  join(separator?: string | undefined): string {\n    return this.toArray().join(separator);\n  }\n\n  toJSON(): any {\n    return this.toArray();\n  }\n\n  //--------------------------\n  // Method not implemented\n  //--------------------------\n\n  [n: number]: T;\n\n  pop(): T | undefined {\n    throw new Error('Method not implemented.');\n  }\n  concat(...items: Array<ConcatArray<T>>): T[];\n  concat(...items: Array<T | ConcatArray<T>>): T[] {\n    throw new Error('Method not implemented.');\n  }\n  reverse(): T[] {\n    throw new Error('Method not implemented.');\n  }\n  shift(): T | undefined {\n    throw new Error('Method not implemented.');\n  }\n  sort(compareFn?: ((a: T, b: T) => number) | undefined): this {\n    throw new Error('Method not implemented.');\n  }\n  splice(start: number, deleteCount?: number | undefined): T[];\n  splice(start: number, deleteCount: number, ...items: T[]): T[] {\n    throw new Error('Method not implemented.');\n  }\n  unshift(...items: T[]): number {\n    throw new Error('Method not implemented.');\n  }\n  fill(value: T, start?: number | undefined, end?: number | undefined): this {\n    throw new Error('Method not implemented.');\n  }\n  copyWithin(target: number, start: number, end?: number | undefined): this {\n    throw new Error('Method not implemented.');\n  }\n  // Object not implemented\n  [Symbol.unscopables] = {};\n\n  //--------------------------------------------------------------------------------\n  // Delegated Array function -- these will not be efficient :grimmice:\n  //--------------------------------------------------------------------------------\n\n  slice(start?: number | undefined, end?: number | undefined): T[] {\n    return this.toArray().slice(start, end);\n  }\n  indexOf(searchElement: T, fromIndex?: number | undefined): number {\n    return this.toArray().indexOf(searchElement, fromIndex);\n  }\n  lastIndexOf(searchElement: T, fromIndex?: number | undefined): number {\n    return this.toArray().lastIndexOf(searchElement, fromIndex);\n  }\n  every<S extends T>(predicate: (value: T, index: number, array: T[]) => value is S, thisArg?: any): this is S[];\n  every(predicate: (value: T, index: number, array: T[]) => unknown, thisArg?: any): boolean;\n  every(predicate: any, thisArg?: unknown): boolean {\n    return this.toArray().every(predicate, thisArg);\n  }\n  some(predicate: (value: T, index: number, array: T[]) => unknown, thisArg?: any): boolean {\n    return this.toArray().some(predicate, thisArg);\n  }\n  reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T;\n  reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T;\n  reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;\n  reduce(callbackfn: unknown, initialValue?: unknown): T {\n    throw new Error('Method not implemented.');\n  }\n  reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T;\n  reduceRight(\n    callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T,\n    initialValue: T\n  ): T;\n  reduceRight<U>(\n    callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U,\n    initialValue: U\n  ): U;\n  reduceRight(callbackfn: unknown, initialValue?: unknown): T {\n    throw new Error('Method not implemented.');\n  }\n  find<S extends T>(\n    predicate: (this: void, value: T, index: number, obj: T[]) => value is S,\n    thisArg?: any\n  ): S | undefined;\n  find(predicate: (value: T, index: number, obj: T[]) => unknown, thisArg?: any): T | undefined {\n    return this.toArray().find(predicate, thisArg);\n  }\n  findIndex(predicate: (value: T, index: number, obj: T[]) => unknown, thisArg?: any): number {\n    return this.toArray().findIndex(predicate, thisArg);\n  }\n  entries(): IterableIterator<[number, T]> {\n    return this.toArray().entries();\n  }\n  keys(): IterableIterator<number> {\n    return this.toArray().keys();\n  }\n  values(): IterableIterator<T> {\n    return this.toArray().values();\n  }\n  includes(searchElement: T, fromIndex?: number | undefined): boolean {\n    return this.toArray().includes(searchElement, fromIndex);\n  }\n  flatMap<U, This = undefined>(\n    callback: (this: This, value: T, index: number, array: T[]) => U | readonly U[],\n    thisArg?: This | undefined\n  ): U[] {\n    return this.toArray().flatMap(callback, thisArg);\n  }\n  flat<A, D extends number = 1>(this: A, depth?: D | undefined): Array<FlatArray<A, D>> {\n    throw new Error('Method not implemented.');\n  }\n}\n\nconst emptyarray: any[] = [];\n\n/**\n * Use functional programming with your vector\n *\n * @deprecated use a simple Arrays\n */\nexport function vectorator<T>(vector: Vector<T>) {\n  return {\n    *[Symbol.iterator]() {\n      for (let i = 0; i < vector.length; i++) {\n        yield vector.get(i);\n      }\n    },\n\n    forEach(iterator: (row: T, index: number, array: T[]) => void): void {\n      for (let i = 0; i < vector.length; i++) {\n        iterator(vector.get(i), i, emptyarray);\n      }\n    },\n\n    map<V>(transform: (item: T, index: number, array: T[]) => V): V[] {\n      const result: V[] = [];\n      for (let i = 0; i < vector.length; i++) {\n        result.push(transform(vector.get(i), i, emptyarray));\n      }\n      return result;\n    },\n\n    /** Add a predicate where you return true if it should *keep* the value */\n    filter(predicate: (item: T, index: number, array: T[]) => boolean): T[] {\n      const result: T[] = [];\n      let count = 0;\n      for (const val of this) {\n        if (predicate(val, count++, emptyarray)) {\n          result.push(val);\n        }\n      }\n      return result;\n    },\n  };\n}\n"],"names":[],"mappings":"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"}