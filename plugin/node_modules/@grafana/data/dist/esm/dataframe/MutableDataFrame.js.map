{"version":3,"file":"MutableDataFrame.js","sources":["../../../src/dataframe/MutableDataFrame.ts"],"sourcesContent":["import { isString } from 'lodash';\n\nimport { QueryResultMeta } from '../types/data';\nimport { Field, DataFrame, DataFrameDTO, FieldDTO, FieldType } from '../types/dataFrame';\nimport { makeFieldParser } from '../utils/fieldParser';\nimport { FunctionalVector } from '../vector/FunctionalVector';\n\nimport { guessFieldTypeFromValue, guessFieldTypeForField, toDataFrameDTO } from './processDataFrame';\n\n/** @deprecated */\nexport type MutableField<T = any> = Field<T>;\n\n/** @deprecated */\ntype MutableVectorCreator = (buffer?: any[]) => any[];\n\nexport const MISSING_VALUE = undefined; // Treated as connected in new graph panel\n\n/**\n * MutableDataFrame is a complex wrapper around the DataFrame interface\n *\n * @deprecated use standard DataFrame, or create one with PartialDataFrame\n */\nexport class MutableDataFrame<T = any> extends FunctionalVector<T> implements DataFrame {\n  name?: string;\n  refId?: string;\n  meta?: QueryResultMeta;\n  fields: MutableField[] = [];\n\n  private first: any[] = [];\n  private creator: MutableVectorCreator;\n\n  constructor(source?: DataFrame | DataFrameDTO, creator?: MutableVectorCreator) {\n    super();\n\n    // This creates the underlying storage buffers\n    this.creator = creator\n      ? creator\n      : (buffer?: any[]) => {\n          return buffer ?? [];\n        };\n\n    // Copy values from\n    if (source) {\n      const { name, refId, meta, fields } = source;\n      if (name) {\n        this.name = name;\n      }\n      if (refId) {\n        this.refId = refId;\n      }\n      if (meta) {\n        this.meta = meta;\n      }\n      if (fields) {\n        for (const f of fields) {\n          this.addField(f);\n        }\n      }\n    }\n\n    // Get Length to show up if you use spread\n    Object.defineProperty(this, 'length', {\n      enumerable: true,\n      get: () => {\n        return this.first.length;\n      },\n    });\n  }\n\n  // Defined for Vector interface\n  get length() {\n    return this.first.length;\n  }\n\n  addFieldFor(value: unknown, name?: string): Field {\n    return this.addField({\n      name: name || '', // Will be filled in\n      type: guessFieldTypeFromValue(value),\n    });\n  }\n\n  addField(f: Field | FieldDTO, startLength?: number): Field {\n    let buffer: any[] | undefined = undefined;\n\n    if (f.values) {\n      buffer = f.values;\n    }\n\n    let type = f.type;\n\n    if (!type && ('time' === f.name || 'Time' === f.name)) {\n      type = FieldType.time;\n    } else {\n      if (!type && buffer && buffer.length) {\n        type = guessFieldTypeFromValue(buffer[0]);\n      }\n      if (!type) {\n        type = FieldType.other;\n      }\n    }\n\n    // Make sure it has a name\n    let name = f.name;\n    if (!name) {\n      name = `Field ${this.fields.length + 1}`;\n    }\n\n    const field: Field = {\n      ...f,\n      name,\n      type,\n      config: f.config || {},\n      values: this.creator(buffer),\n    };\n\n    if (type === FieldType.other) {\n      type = guessFieldTypeForField(field);\n      if (type) {\n        field.type = type;\n      }\n    }\n\n    this.fields.push(field);\n    this.first = this.fields[0].values;\n\n    // Make sure the field starts with a given length\n    if (startLength) {\n      while (field.values.length < startLength) {\n        field.values.push(MISSING_VALUE);\n      }\n    } else {\n      this.validate();\n    }\n\n    return field;\n  }\n\n  validate() {\n    // Make sure all arrays are the same length\n    const length = this.fields.reduce((v: number, f) => {\n      return Math.max(v, f.values.length);\n    }, 0);\n\n    // Add empty elements until everything matches\n    for (const field of this.fields) {\n      while (field.values.length !== length) {\n        field.values.push(MISSING_VALUE);\n      }\n    }\n  }\n\n  private parsers: Map<Field, (v: string) => any> | undefined = undefined;\n\n  /**\n   * @deprecated unclear if this is actually used\n   */\n  setParser(field: Field, parser: (v: string) => any) {\n    if (!this.parsers) {\n      this.parsers = new Map<Field, (v: string) => any>();\n    }\n    this.parsers.set(field, parser);\n    return parser;\n  }\n\n  private parseValue(field: Field, v: string) {\n    let p = this.parsers?.get(field);\n    if (!p) {\n      p = this.setParser(field, makeFieldParser(v, field));\n    }\n    return p(v);\n  }\n\n  /**\n   * This will add each value to the corresponding column\n   */\n  appendRow(row: unknown[]) {\n    // Add any extra columns\n    for (let i = this.fields.length; i < row.length; i++) {\n      this.addField({\n        name: `Field ${i + 1}`,\n        type: guessFieldTypeFromValue(row[i]),\n      });\n    }\n\n    // The first line may change the field types\n    if (this.length < 1) {\n      for (let i = 0; i < this.fields.length; i++) {\n        const f = this.fields[i];\n        if (!f.type || f.type === FieldType.other) {\n          f.type = guessFieldTypeFromValue(row[i]);\n        }\n      }\n    }\n\n    for (let i = 0; i < this.fields.length; i++) {\n      const f = this.fields[i];\n      let v = row[i];\n      if (f.type !== FieldType.string && isString(v)) {\n        v = this.parseValue(f, v);\n      }\n      f.values.push(v);\n    }\n  }\n\n  /** support standard array push syntax */\n  push(...vals: T[]): number {\n    for (const v of vals) {\n      this.add(v);\n    }\n    return this.length;\n  }\n\n  reverse() {\n    for (const field of this.fields) {\n      field.values.reverse();\n    }\n    return this;\n  }\n\n  /**\n   * Add values from an object to corresponding fields. Similar to appendRow but does not create new fields.\n   */\n  add(value: T): void {\n    // Will add one value for every field\n    const obj = value as any;\n    for (const field of this.fields) {\n      let val = obj[field.name];\n\n      if (field.type !== FieldType.string && isString(val)) {\n        val = this.parseValue(field, val);\n      }\n\n      if (val === undefined) {\n        val = MISSING_VALUE;\n      }\n\n      field.values.push(val);\n    }\n  }\n\n  set(index: number, value: T) {\n    if (index > this.length) {\n      throw new Error('Unable to set value beyond current length');\n    }\n\n    const obj = (value as any) || {};\n    for (const field of this.fields) {\n      field.values[index] = obj[field.name];\n    }\n  }\n\n  /**\n   * Get an object with a property for each field in the DataFrame\n   */\n  get(idx: number): T {\n    const v: any = {};\n    for (const field of this.fields) {\n      v[field.name] = field.values[idx];\n    }\n    return v as T;\n  }\n\n  /**\n   * The simplified JSON values used in JSON.stringify()\n   */\n  toJSON() {\n    return toDataFrameDTO(this);\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAeO,MAAM,aAAgB,GAAA,KAAA,EAAA;AAOtB,MAAM,yBAAkC,gBAAyC,CAAA;AAAA,EAStF,WAAA,CAAY,QAAmC,OAAgC,EAAA;AAC7E,IAAM,KAAA,EAAA,CAAA;AATR,IAAA,aAAA,CAAA,IAAA,EAAA,MAAA,CAAA,CAAA;AACA,IAAA,aAAA,CAAA,IAAA,EAAA,OAAA,CAAA,CAAA;AACA,IAAA,aAAA,CAAA,IAAA,EAAA,MAAA,CAAA,CAAA;AACA,IAAA,aAAA,CAAA,IAAA,EAAA,QAAA,EAAyB,EAAC,CAAA,CAAA;AAE1B,IAAA,aAAA,CAAA,IAAA,EAAQ,SAAe,EAAC,CAAA,CAAA;AACxB,IAAQ,aAAA,CAAA,IAAA,EAAA,SAAA,CAAA,CAAA;AA0HR,IAAQ,aAAA,CAAA,IAAA,EAAA,SAAA,CAAA,CAAA;AApHN,IAAA,IAAA,CAAK,OAAU,GAAA,OAAA,GACX,OACA,GAAA,CAAC,MAAmB,KAAA;AAClB,MAAA,OAAO,0BAAU,EAAC,CAAA;AAAA,KACpB,CAAA;AAGJ,IAAA,IAAI,MAAQ,EAAA;AACV,MAAA,MAAM,EAAE,IAAA,EAAM,KAAO,EAAA,IAAA,EAAM,QAAW,GAAA,MAAA,CAAA;AACtC,MAAA,IAAI,IAAM,EAAA;AACR,QAAA,IAAA,CAAK,IAAO,GAAA,IAAA,CAAA;AAAA,OACd;AACA,MAAA,IAAI,KAAO,EAAA;AACT,QAAA,IAAA,CAAK,KAAQ,GAAA,KAAA,CAAA;AAAA,OACf;AACA,MAAA,IAAI,IAAM,EAAA;AACR,QAAA,IAAA,CAAK,IAAO,GAAA,IAAA,CAAA;AAAA,OACd;AACA,MAAA,IAAI,MAAQ,EAAA;AACV,QAAA,KAAA,MAAW,KAAK,MAAQ,EAAA;AACtB,UAAA,IAAA,CAAK,SAAS,CAAC,CAAA,CAAA;AAAA,SACjB;AAAA,OACF;AAAA,KACF;AAGA,IAAO,MAAA,CAAA,cAAA,CAAe,MAAM,QAAU,EAAA;AAAA,MACpC,UAAY,EAAA,IAAA;AAAA,MACZ,KAAK,MAAM;AACT,QAAA,OAAO,KAAK,KAAM,CAAA,MAAA,CAAA;AAAA,OACpB;AAAA,KACD,CAAA,CAAA;AAAA,GACH;AAAA;AAAA,EAGA,IAAI,MAAS,GAAA;AACX,IAAA,OAAO,KAAK,KAAM,CAAA,MAAA,CAAA;AAAA,GACpB;AAAA,EAEA,WAAA,CAAY,OAAgB,IAAsB,EAAA;AAChD,IAAA,OAAO,KAAK,QAAS,CAAA;AAAA,MACnB,MAAM,IAAQ,IAAA,EAAA;AAAA;AAAA,MACd,IAAA,EAAM,wBAAwB,KAAK,CAAA;AAAA,KACpC,CAAA,CAAA;AAAA,GACH;AAAA,EAEA,QAAA,CAAS,GAAqB,WAA6B,EAAA;AACzD,IAAA,IAAI,MAA4B,GAAA,KAAA,CAAA,CAAA;AAEhC,IAAA,IAAI,EAAE,MAAQ,EAAA;AACZ,MAAA,MAAA,GAAS,CAAE,CAAA,MAAA,CAAA;AAAA,KACb;AAEA,IAAA,IAAI,OAAO,CAAE,CAAA,IAAA,CAAA;AAEb,IAAA,IAAI,CAAC,IAAS,KAAA,MAAA,KAAW,EAAE,IAAQ,IAAA,MAAA,KAAW,EAAE,IAAO,CAAA,EAAA;AACrD,MAAA,IAAA,GAAO,SAAU,CAAA,IAAA,CAAA;AAAA,KACZ,MAAA;AACL,MAAA,IAAI,CAAC,IAAA,IAAQ,MAAU,IAAA,MAAA,CAAO,MAAQ,EAAA;AACpC,QAAO,IAAA,GAAA,uBAAA,CAAwB,MAAO,CAAA,CAAC,CAAC,CAAA,CAAA;AAAA,OAC1C;AACA,MAAA,IAAI,CAAC,IAAM,EAAA;AACT,QAAA,IAAA,GAAO,SAAU,CAAA,KAAA,CAAA;AAAA,OACnB;AAAA,KACF;AAGA,IAAA,IAAI,OAAO,CAAE,CAAA,IAAA,CAAA;AACb,IAAA,IAAI,CAAC,IAAM,EAAA;AACT,MAAA,IAAA,GAAO,CAAS,MAAA,EAAA,IAAA,CAAK,MAAO,CAAA,MAAA,GAAS,CAAC,CAAA,CAAA,CAAA;AAAA,KACxC;AAEA,IAAM,MAAA,KAAA,GAAe,iCAChB,CADgB,CAAA,EAAA;AAAA,MAEnB,IAAA;AAAA,MACA,IAAA;AAAA,MACA,MAAA,EAAQ,CAAE,CAAA,MAAA,IAAU,EAAC;AAAA,MACrB,MAAA,EAAQ,IAAK,CAAA,OAAA,CAAQ,MAAM,CAAA;AAAA,KAC7B,CAAA,CAAA;AAEA,IAAI,IAAA,IAAA,KAAS,UAAU,KAAO,EAAA;AAC5B,MAAA,IAAA,GAAO,uBAAuB,KAAK,CAAA,CAAA;AACnC,MAAA,IAAI,IAAM,EAAA;AACR,QAAA,KAAA,CAAM,IAAO,GAAA,IAAA,CAAA;AAAA,OACf;AAAA,KACF;AAEA,IAAK,IAAA,CAAA,MAAA,CAAO,KAAK,KAAK,CAAA,CAAA;AACtB,IAAA,IAAA,CAAK,KAAQ,GAAA,IAAA,CAAK,MAAO,CAAA,CAAC,CAAE,CAAA,MAAA,CAAA;AAG5B,IAAA,IAAI,WAAa,EAAA;AACf,MAAO,OAAA,KAAA,CAAM,MAAO,CAAA,MAAA,GAAS,WAAa,EAAA;AACxC,QAAM,KAAA,CAAA,MAAA,CAAO,KAAK,aAAa,CAAA,CAAA;AAAA,OACjC;AAAA,KACK,MAAA;AACL,MAAA,IAAA,CAAK,QAAS,EAAA,CAAA;AAAA,KAChB;AAEA,IAAO,OAAA,KAAA,CAAA;AAAA,GACT;AAAA,EAEA,QAAW,GAAA;AAET,IAAA,MAAM,SAAS,IAAK,CAAA,MAAA,CAAO,MAAO,CAAA,CAAC,GAAW,CAAM,KAAA;AAClD,MAAA,OAAO,IAAK,CAAA,GAAA,CAAI,CAAG,EAAA,CAAA,CAAE,OAAO,MAAM,CAAA,CAAA;AAAA,OACjC,CAAC,CAAA,CAAA;AAGJ,IAAW,KAAA,MAAA,KAAA,IAAS,KAAK,MAAQ,EAAA;AAC/B,MAAO,OAAA,KAAA,CAAM,MAAO,CAAA,MAAA,KAAW,MAAQ,EAAA;AACrC,QAAM,KAAA,CAAA,MAAA,CAAO,KAAK,aAAa,CAAA,CAAA;AAAA,OACjC;AAAA,KACF;AAAA,GACF;AAAA;AAAA;AAAA;AAAA,EAOA,SAAA,CAAU,OAAc,MAA4B,EAAA;AAClD,IAAI,IAAA,CAAC,KAAK,OAAS,EAAA;AACjB,MAAK,IAAA,CAAA,OAAA,uBAAc,GAA+B,EAAA,CAAA;AAAA,KACpD;AACA,IAAK,IAAA,CAAA,OAAA,CAAQ,GAAI,CAAA,KAAA,EAAO,MAAM,CAAA,CAAA;AAC9B,IAAO,OAAA,MAAA,CAAA;AAAA,GACT;AAAA,EAEQ,UAAA,CAAW,OAAc,CAAW,EAAA;AApK9C,IAAA,IAAA,EAAA,CAAA;AAqKI,IAAA,IAAI,CAAI,GAAA,CAAA,EAAA,GAAA,IAAA,CAAK,OAAL,KAAA,IAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAc,GAAI,CAAA,KAAA,CAAA,CAAA;AAC1B,IAAA,IAAI,CAAC,CAAG,EAAA;AACN,MAAA,CAAA,GAAI,KAAK,SAAU,CAAA,KAAA,EAAO,eAAgB,CAAA,CAAA,EAAG,KAAK,CAAC,CAAA,CAAA;AAAA,KACrD;AACA,IAAA,OAAO,EAAE,CAAC,CAAA,CAAA;AAAA,GACZ;AAAA;AAAA;AAAA;AAAA,EAKA,UAAU,GAAgB,EAAA;AAExB,IAAA,KAAA,IAAS,IAAI,IAAK,CAAA,MAAA,CAAO,QAAQ,CAAI,GAAA,GAAA,CAAI,QAAQ,CAAK,EAAA,EAAA;AACpD,MAAA,IAAA,CAAK,QAAS,CAAA;AAAA,QACZ,IAAA,EAAM,CAAS,MAAA,EAAA,CAAA,GAAI,CAAC,CAAA,CAAA;AAAA,QACpB,IAAM,EAAA,uBAAA,CAAwB,GAAI,CAAA,CAAC,CAAC,CAAA;AAAA,OACrC,CAAA,CAAA;AAAA,KACH;AAGA,IAAI,IAAA,IAAA,CAAK,SAAS,CAAG,EAAA;AACnB,MAAA,KAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,IAAK,CAAA,MAAA,CAAO,QAAQ,CAAK,EAAA,EAAA;AAC3C,QAAM,MAAA,CAAA,GAAI,IAAK,CAAA,MAAA,CAAO,CAAC,CAAA,CAAA;AACvB,QAAA,IAAI,CAAC,CAAE,CAAA,IAAA,IAAQ,CAAE,CAAA,IAAA,KAAS,UAAU,KAAO,EAAA;AACzC,UAAA,CAAA,CAAE,IAAO,GAAA,uBAAA,CAAwB,GAAI,CAAA,CAAC,CAAC,CAAA,CAAA;AAAA,SACzC;AAAA,OACF;AAAA,KACF;AAEA,IAAA,KAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,IAAK,CAAA,MAAA,CAAO,QAAQ,CAAK,EAAA,EAAA;AAC3C,MAAM,MAAA,CAAA,GAAI,IAAK,CAAA,MAAA,CAAO,CAAC,CAAA,CAAA;AACvB,MAAI,IAAA,CAAA,GAAI,IAAI,CAAC,CAAA,CAAA;AACb,MAAA,IAAI,EAAE,IAAS,KAAA,SAAA,CAAU,MAAU,IAAA,QAAA,CAAS,CAAC,CAAG,EAAA;AAC9C,QAAI,CAAA,GAAA,IAAA,CAAK,UAAW,CAAA,CAAA,EAAG,CAAC,CAAA,CAAA;AAAA,OAC1B;AACA,MAAE,CAAA,CAAA,MAAA,CAAO,KAAK,CAAC,CAAA,CAAA;AAAA,KACjB;AAAA,GACF;AAAA;AAAA,EAGA,QAAQ,IAAmB,EAAA;AACzB,IAAA,KAAA,MAAW,KAAK,IAAM,EAAA;AACpB,MAAA,IAAA,CAAK,IAAI,CAAC,CAAA,CAAA;AAAA,KACZ;AACA,IAAA,OAAO,IAAK,CAAA,MAAA,CAAA;AAAA,GACd;AAAA,EAEA,OAAU,GAAA;AACR,IAAW,KAAA,MAAA,KAAA,IAAS,KAAK,MAAQ,EAAA;AAC/B,MAAA,KAAA,CAAM,OAAO,OAAQ,EAAA,CAAA;AAAA,KACvB;AACA,IAAO,OAAA,IAAA,CAAA;AAAA,GACT;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,KAAgB,EAAA;AAElB,IAAA,MAAM,GAAM,GAAA,KAAA,CAAA;AACZ,IAAW,KAAA,MAAA,KAAA,IAAS,KAAK,MAAQ,EAAA;AAC/B,MAAI,IAAA,GAAA,GAAM,GAAI,CAAA,KAAA,CAAM,IAAI,CAAA,CAAA;AAExB,MAAA,IAAI,MAAM,IAAS,KAAA,SAAA,CAAU,MAAU,IAAA,QAAA,CAAS,GAAG,CAAG,EAAA;AACpD,QAAM,GAAA,GAAA,IAAA,CAAK,UAAW,CAAA,KAAA,EAAO,GAAG,CAAA,CAAA;AAAA,OAClC;AAEA,MAAA,IAAI,QAAQ,KAAW,CAAA,EAAA;AACrB,QAAM,GAAA,GAAA,aAAA,CAAA;AAAA,OACR;AAEA,MAAM,KAAA,CAAA,MAAA,CAAO,KAAK,GAAG,CAAA,CAAA;AAAA,KACvB;AAAA,GACF;AAAA,EAEA,GAAA,CAAI,OAAe,KAAU,EAAA;AAC3B,IAAI,IAAA,KAAA,GAAQ,KAAK,MAAQ,EAAA;AACvB,MAAM,MAAA,IAAI,MAAM,2CAA2C,CAAA,CAAA;AAAA,KAC7D;AAEA,IAAM,MAAA,GAAA,GAAO,SAAiB,EAAC,CAAA;AAC/B,IAAW,KAAA,MAAA,KAAA,IAAS,KAAK,MAAQ,EAAA;AAC/B,MAAA,KAAA,CAAM,MAAO,CAAA,KAAK,CAAI,GAAA,GAAA,CAAI,MAAM,IAAI,CAAA,CAAA;AAAA,KACtC;AAAA,GACF;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,GAAgB,EAAA;AAClB,IAAA,MAAM,IAAS,EAAC,CAAA;AAChB,IAAW,KAAA,MAAA,KAAA,IAAS,KAAK,MAAQ,EAAA;AAC/B,MAAA,CAAA,CAAE,KAAM,CAAA,IAAI,CAAI,GAAA,KAAA,CAAM,OAAO,GAAG,CAAA,CAAA;AAAA,KAClC;AACA,IAAO,OAAA,CAAA,CAAA;AAAA,GACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAS,GAAA;AACP,IAAA,OAAO,eAAe,IAAI,CAAA,CAAA;AAAA,GAC5B;AACF;;;;"}