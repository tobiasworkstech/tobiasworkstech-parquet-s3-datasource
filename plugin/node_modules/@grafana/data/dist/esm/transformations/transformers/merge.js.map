{"version":3,"file":"merge.js","sources":["../../../../src/transformations/transformers/merge.ts"],"sourcesContent":["import { omit } from 'lodash';\nimport { map } from 'rxjs/operators';\n\nimport { MutableDataFrame } from '../../dataframe';\nimport { DataFrame, Field } from '../../types/dataFrame';\nimport { DataTransformerInfo, TransformationApplicabilityLevels } from '../../types/transformations';\n\nimport { DataTransformerID } from './ids';\n\ninterface ValuePointer {\n  key: string;\n  index: number;\n}\n\nexport interface MergeTransformerOptions {}\n\nexport const mergeTransformer: DataTransformerInfo<MergeTransformerOptions> = {\n  id: DataTransformerID.merge,\n  name: 'Merge series/tables',\n  description: 'Merges multiple series/tables into a single serie/table',\n  defaultOptions: {},\n  isApplicable: (data: DataFrame[]) => {\n    return data.length > 1\n      ? TransformationApplicabilityLevels.Applicable\n      : TransformationApplicabilityLevels.NotApplicable;\n  },\n  isApplicableDescription: (data: DataFrame[]) => {\n    return `The merge transformation requires at least 2 data series to work. There is currently ${data.length} data series.`;\n  },\n  operator: (options) => (source) =>\n    source.pipe(\n      map((dataFrames) => {\n        if (!Array.isArray(dataFrames) || dataFrames.length <= 1) {\n          return dataFrames;\n        }\n\n        const data = dataFrames.filter((frame) => frame.fields.length > 0);\n\n        if (data.length === 0) {\n          return [dataFrames[0]];\n        }\n\n        const fieldNames = new Set<string>();\n        const fieldIndexByName: Record<string, Record<number, number>> = {};\n        const fieldNamesForKey: string[] = [];\n        const dataFrame = new MutableDataFrame();\n\n        for (let frameIndex = 0; frameIndex < data.length; frameIndex++) {\n          const frame = data[frameIndex];\n\n          for (let fieldIndex = 0; fieldIndex < frame.fields.length; fieldIndex++) {\n            const field = frame.fields[fieldIndex];\n\n            if (!fieldNames.has(field.name)) {\n              dataFrame.addField(copyFieldStructure(field));\n              fieldNames.add(field.name);\n            }\n\n            fieldIndexByName[field.name] = fieldIndexByName[field.name] || {};\n            fieldIndexByName[field.name][frameIndex] = fieldIndex;\n\n            if (data.length - 1 !== frameIndex) {\n              continue;\n            }\n\n            if (fieldExistsInAllFrames(fieldIndexByName, field, data)) {\n              fieldNamesForKey.push(field.name);\n            }\n          }\n        }\n\n        if (fieldNamesForKey.length === 0) {\n          return dataFrames;\n        }\n\n        const valuesByKey: Record<string, Array<Record<string, unknown>>> = {};\n        const valuesInOrder: ValuePointer[] = [];\n        const keyFactory = createKeyFactory(data, fieldIndexByName, fieldNamesForKey);\n        const valueMapper = createValueMapper(data, fieldNames, fieldIndexByName);\n\n        for (let frameIndex = 0; frameIndex < data.length; frameIndex++) {\n          const frame = data[frameIndex];\n\n          for (let valueIndex = 0; valueIndex < frame.length; valueIndex++) {\n            const key = keyFactory(frameIndex, valueIndex);\n            const value = valueMapper(frameIndex, valueIndex);\n\n            if (!Array.isArray(valuesByKey[key])) {\n              valuesByKey[key] = [value];\n              valuesInOrder.push(createPointer(key, valuesByKey));\n              continue;\n            }\n\n            let valueWasMerged = false;\n\n            valuesByKey[key] = valuesByKey[key].map((existing) => {\n              if (!isMergable(existing, value)) {\n                return existing;\n              }\n              valueWasMerged = true;\n              return { ...existing, ...value };\n            });\n\n            if (!valueWasMerged) {\n              valuesByKey[key].push(value);\n              valuesInOrder.push(createPointer(key, valuesByKey));\n            }\n          }\n        }\n\n        for (const pointer of valuesInOrder) {\n          const value = valuesByKey[pointer.key][pointer.index];\n\n          if (value) {\n            dataFrame.add(value);\n          }\n        }\n\n        return [dataFrame];\n      })\n    ),\n};\n\nconst copyFieldStructure = (field: Field): Field => {\n  return {\n    ...omit(field, ['values', 'state', 'labels', 'config']),\n    values: [],\n    config: {\n      ...omit(field.config, 'displayName'),\n    },\n  };\n};\n\nconst createKeyFactory = (\n  data: DataFrame[],\n  fieldPointerByName: Record<string, Record<string, number>>,\n  keyFieldNames: string[]\n) => {\n  const factoryIndex = keyFieldNames.reduce((index: Record<string, number[]>, fieldName) => {\n    return Object.keys(fieldPointerByName[fieldName]).reduce((index: Record<string, number[]>, frameIndex) => {\n      index[frameIndex] = index[frameIndex] || [];\n      index[frameIndex].push(fieldPointerByName[fieldName][frameIndex]);\n      return index;\n    }, index);\n  }, {});\n\n  return (frameIndex: number, valueIndex: number): string => {\n    return factoryIndex[frameIndex].reduce((key: string, fieldIndex: number) => {\n      return key + data[frameIndex].fields[fieldIndex].values[valueIndex];\n    }, '');\n  };\n};\n\nconst createValueMapper = (\n  data: DataFrame[],\n  fieldByName: Set<string>,\n  fieldIndexByName: Record<string, Record<number, number>>\n) => {\n  return (frameIndex: number, valueIndex: number) => {\n    const value: Record<string, unknown> = {};\n    const fieldNames = Array.from(fieldByName);\n\n    for (const fieldName of fieldNames) {\n      const fieldIndexByFrameIndex = fieldIndexByName[fieldName];\n      if (!fieldIndexByFrameIndex) {\n        continue;\n      }\n\n      const fieldIndex = fieldIndexByFrameIndex[frameIndex];\n      if (typeof fieldIndex !== 'number') {\n        continue;\n      }\n\n      const frame = data[frameIndex];\n      if (!frame || !frame.fields) {\n        continue;\n      }\n\n      const field = frame.fields[fieldIndex];\n      if (!field || !field.values) {\n        continue;\n      }\n\n      value[fieldName] = field.values[valueIndex];\n    }\n\n    return value;\n  };\n};\n\nconst isMergable = (existing: Record<string, unknown>, value: Record<string, unknown>): boolean => {\n  let mergable = true;\n\n  for (const prop in value) {\n    if (typeof existing[prop] === 'undefined') {\n      continue;\n    }\n\n    if (existing[prop] === null) {\n      continue;\n    }\n\n    if (existing[prop] !== value[prop]) {\n      mergable = false;\n      break;\n    }\n  }\n\n  return mergable;\n};\n\nconst fieldExistsInAllFrames = (\n  fieldIndexByName: Record<string, Record<number, number>>,\n  field: Field,\n  data: DataFrame[]\n) => {\n  return Object.keys(fieldIndexByName[field.name]).length === data.length;\n};\n\nconst createPointer = (key: string, valuesByKey: Record<string, Array<Record<string, unknown>>>): ValuePointer => {\n  return {\n    key,\n    index: valuesByKey[key].length - 1,\n  };\n};\n"],"names":["index"],"mappings":"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"}