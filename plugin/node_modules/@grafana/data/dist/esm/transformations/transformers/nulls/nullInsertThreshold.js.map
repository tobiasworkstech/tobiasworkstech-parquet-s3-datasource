{"version":3,"file":"nullInsertThreshold.js","sources":["../../../../../src/transformations/transformers/nulls/nullInsertThreshold.ts"],"sourcesContent":["import { DataFrame, FieldType } from '../../../types';\n\ntype InsertMode = (prev: number, next: number, threshold: number) => number;\n\nconst INSERT_MODES = {\n  threshold: (prev: number, next: number, threshold: number) => prev + threshold,\n  midpoint: (prev: number, next: number, threshold: number) => (prev + next) / 2,\n  // previous time + 1ms to prevent StateTimeline from forward-interpolating prior state\n  plusone: (prev: number, next: number, threshold: number) => prev + 1,\n};\n\ninterface NullInsertOptions {\n  frame: DataFrame;\n  refFieldName?: string | null;\n  refFieldPseudoMax?: number;\n  refFieldPseudoMin?: number;\n  insertMode?: InsertMode;\n}\n\nfunction getRefField(frame: DataFrame, refFieldName?: string | null) {\n  return frame.fields.find((field) => {\n    // note: getFieldDisplayName() would require full DF[]\n    return refFieldName != null ? field.name === refFieldName : field.type === FieldType.time;\n  });\n}\n\n/** @internal */\nexport function applyNullInsertThreshold(opts: NullInsertOptions): DataFrame {\n  if (opts.frame.length === 0) {\n    return opts.frame;\n  }\n\n  let thorough = true;\n  let { frame, refFieldName, refFieldPseudoMax, refFieldPseudoMin, insertMode } = opts;\n\n  if (!insertMode) {\n    insertMode = INSERT_MODES.threshold;\n  }\n\n  const refField = getRefField(frame, refFieldName);\n\n  if (refField == null) {\n    return frame;\n  }\n\n  refField.state = {\n    ...refField.state,\n    nullThresholdApplied: true,\n  };\n\n  const thresholds = frame.fields.map((field) => field.config.custom?.insertNulls || refField.config.interval || null);\n\n  const uniqueThresholds = new Set<number>(thresholds);\n\n  uniqueThresholds.delete(null as any);\n\n  if (uniqueThresholds.size === 0) {\n    return frame;\n  }\n\n  if (uniqueThresholds.size === 1) {\n    const threshold = uniqueThresholds.values().next().value;\n\n    if (threshold <= 0) {\n      return frame;\n    }\n\n    const refValues = refField.values;\n\n    const frameValues = frame.fields.map((field) => field.values);\n\n    const filledFieldValues = nullInsertThreshold(\n      refValues,\n      frameValues,\n      threshold,\n      refFieldPseudoMin,\n      refFieldPseudoMax,\n      insertMode,\n      thorough\n    );\n\n    if (filledFieldValues === frameValues) {\n      return frame;\n    }\n\n    return {\n      ...frame,\n      length: filledFieldValues[0].length,\n      fields: frame.fields.map((field, i) => ({\n        ...field,\n        values: filledFieldValues[i],\n      })),\n    };\n  }\n\n  // TODO: unique threshold-per-field (via overrides) is unimplemented\n  // should be done by processing each (refField + thresholdA-field1 + thresholdA-field2...)\n  // as a separate nullInsertThreshold() dataset, then re-join into single dataset via join()\n  return frame;\n}\n\nfunction nullInsertThreshold(\n  refValues: number[],\n  frameValues: any[][],\n  threshold: number,\n  refFieldPseudoMin: number | null = null,\n  // will insert a trailing null when refFieldPseudoMax > last datapoint + threshold\n  refFieldPseudoMax: number | null = null,\n  getInsertValue: InsertMode,\n  // will insert the value at every missing interval\n  thorough: boolean\n) {\n  const len = refValues.length;\n  const refValuesNew: number[] = [];\n\n  // Continuously subtract the threshold from the first data point, filling in insert values accordingly\n  if (refFieldPseudoMin != null && refFieldPseudoMin < refValues[0]) {\n    let preFillCount = Math.ceil((refValues[0] - refFieldPseudoMin) / threshold);\n    // this will be 0 or 1 threshold increment left of visible range\n    let prevSlot = refValues[0] - preFillCount * threshold;\n\n    while (prevSlot < refValues[0]) {\n      // (prevSlot - threshold) is used to simulate the previous 'real' data point, as getInsertValue expects\n      refValuesNew.push(getInsertValue(prevSlot - threshold, prevSlot, threshold));\n      prevSlot += threshold;\n    }\n  }\n\n  // Insert initial value\n  refValuesNew.push(refValues[0]);\n\n  let prevValue: number = refValues[0];\n\n  // Fill nulls when a value is greater than the threshold value\n  for (let i = 1; i < len; i++) {\n    const curValue = refValues[i];\n\n    while (curValue - prevValue > threshold) {\n      refValuesNew.push(getInsertValue(prevValue, curValue, threshold));\n\n      prevValue += threshold;\n\n      if (!thorough) {\n        break;\n      }\n    }\n\n    refValuesNew.push(curValue);\n\n    prevValue = curValue;\n  }\n\n  // At the end of the sequence\n  if (refFieldPseudoMax != null && refFieldPseudoMax > prevValue) {\n    while (prevValue + threshold < refFieldPseudoMax) {\n      refValuesNew.push(getInsertValue(prevValue, refFieldPseudoMax, threshold));\n      prevValue += threshold;\n    }\n  }\n\n  const filledLen = refValuesNew.length;\n\n  if (filledLen === len) {\n    return frameValues;\n  }\n\n  const filledFieldValues: any[][] = [];\n\n  for (let fieldValues of frameValues) {\n    let filledValues;\n\n    if (fieldValues !== refValues) {\n      filledValues = Array(filledLen);\n\n      for (let i = 0, j = 0; i < filledLen; i++) {\n        filledValues[i] = refValues[j] === refValuesNew[i] ? fieldValues[j++] : null;\n      }\n    } else {\n      filledValues = refValuesNew;\n    }\n\n    filledFieldValues.push(filledValues);\n  }\n\n  return filledFieldValues;\n}\n"],"names":[],"mappings":"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"}