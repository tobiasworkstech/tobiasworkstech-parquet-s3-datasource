{"version":3,"file":"groupToNestedTable.js","sources":["../../../../src/transformations/transformers/groupToNestedTable.ts"],"sourcesContent":["import { map } from 'rxjs/operators';\n\nimport { guessFieldTypeForField } from '../../dataframe/processDataFrame';\nimport { getFieldDisplayName } from '../../field/fieldState';\nimport { DataFrame, Field, FieldType } from '../../types/dataFrame';\nimport { DataTransformerInfo } from '../../types/transformations';\nimport { ReducerID, reduceField } from '../fieldReducer';\n\nimport { GroupByFieldOptions, createGroupedFields, groupValuesByKey } from './groupBy';\nimport { DataTransformerID } from './ids';\n\nexport const SHOW_NESTED_HEADERS_DEFAULT = true;\n\nexport enum GroupByOperationID {\n  aggregate = 'aggregate',\n  groupBy = 'groupby',\n}\n\nexport interface GroupToNestedTableTransformerOptions {\n  showSubframeHeaders?: boolean;\n  fields: Record<string, GroupByFieldOptions>;\n}\n\ninterface FieldMap {\n  [key: string]: Field;\n}\n\nexport const groupToNestedTable: DataTransformerInfo<GroupToNestedTableTransformerOptions> = {\n  id: DataTransformerID.groupToNestedTable,\n  name: 'Group to nested tables',\n  description: 'Group data by a field value and create nested tables with the grouped data',\n  defaultOptions: {\n    showSubframeHeaders: SHOW_NESTED_HEADERS_DEFAULT,\n    fields: {},\n  },\n\n  /**\n   * Return a modified copy of the series. If the transform is not or should not\n   * be applied, just return the input series\n   */\n  operator: (options) => (source) =>\n    source.pipe(\n      map((data) => {\n        const hasValidConfig = Object.keys(options.fields).find(\n          (name) => options.fields[name].operation === GroupByOperationID.groupBy\n        );\n        if (!hasValidConfig) {\n          return data;\n        }\n\n        const processed: DataFrame[] = [];\n\n        for (const frame of data) {\n          // Create a list of fields to group on\n          // If there are none we skip the rest\n          const groupByFields: Field[] = frame.fields.filter((field) => shouldGroupOnField(field, options));\n          if (groupByFields.length === 0) {\n            continue;\n          }\n\n          // Group the values by fields and groups so we can get all values for a\n          // group for a given field.\n          const valuesByGroupKey = groupValuesByKey(frame, groupByFields);\n\n          // Add the grouped fields to the resulting fields of the transformation\n          const fields: Field[] = createGroupedFields(groupByFields, valuesByGroupKey);\n\n          // Group data into sub frames so they will display as tables\n          const subFrames: DataFrame[][] = groupToSubframes(valuesByGroupKey, options);\n\n          // Then for each calculations configured, compute and add a new field (column)\n          for (let i = 0; i < frame.fields.length; i++) {\n            const field = frame.fields[i];\n\n            if (!shouldCalculateField(field, options)) {\n              continue;\n            }\n\n            const fieldName = getFieldDisplayName(field);\n            const aggregations = options.fields[fieldName].aggregations;\n            const valuesByAggregation: Record<string, unknown[]> = {};\n\n            valuesByGroupKey.forEach((value) => {\n              const fieldWithValuesForGroup = value[fieldName];\n              const results = reduceField({\n                field: fieldWithValuesForGroup,\n                reducers: aggregations,\n              });\n\n              for (const aggregation of aggregations) {\n                if (!Array.isArray(valuesByAggregation[aggregation])) {\n                  valuesByAggregation[aggregation] = [];\n                }\n                valuesByAggregation[aggregation].push(results[aggregation]);\n              }\n            });\n\n            for (const aggregation of aggregations) {\n              const aggregationField: Field = {\n                name: `${fieldName} (${aggregation})`,\n                values: valuesByAggregation[aggregation],\n                type: FieldType.other,\n                config: {},\n              };\n\n              aggregationField.type = detectFieldType(aggregation, field, aggregationField);\n              fields.push(aggregationField);\n            }\n          }\n\n          fields.push({\n            config: {},\n            name: 'Nested frames',\n            type: FieldType.nestedFrames,\n            values: subFrames,\n          });\n\n          processed.push({\n            fields,\n            length: valuesByGroupKey.size,\n          });\n        }\n\n        return processed;\n      })\n    ),\n};\n\n/**\n * Given the appropriate data, create a sub-frame\n * which can then be displayed in a sub-table.\n */\nfunction createSubframe(fields: Field[], frameLength: number, options: GroupToNestedTableTransformerOptions) {\n  const showHeaders =\n    options.showSubframeHeaders === undefined ? SHOW_NESTED_HEADERS_DEFAULT : options.showSubframeHeaders;\n\n  return {\n    meta: { custom: { noHeader: !showHeaders } },\n    length: frameLength,\n    fields,\n  };\n}\n\n/**\n * Determines whether a field should be grouped on.\n *\n * @returns boolean\n *  This will return _true_ if a field should be grouped on and _false_ if it should not.\n */\nconst shouldGroupOnField = (field: Field, options: GroupToNestedTableTransformerOptions): boolean => {\n  const fieldName = getFieldDisplayName(field);\n  return options?.fields[fieldName]?.operation === GroupByOperationID.groupBy;\n};\n\n/**\n * Determines whether field aggregations should be calculated\n * @returns boolean\n *  This will return _true_ if a field should be calculated and _false_ if it should not.\n */\nconst shouldCalculateField = (field: Field, options: GroupToNestedTableTransformerOptions): boolean => {\n  const fieldName = getFieldDisplayName(field);\n  return (\n    options?.fields[fieldName]?.operation === GroupByOperationID.aggregate &&\n    Array.isArray(options?.fields[fieldName].aggregations) &&\n    options?.fields[fieldName].aggregations.length > 0\n  );\n};\n\n/**\n * Detect the type of field given the relevant aggregation.\n */\nconst detectFieldType = (aggregation: string, sourceField: Field, targetField: Field): FieldType => {\n  switch (aggregation) {\n    case ReducerID.allIsNull:\n      return FieldType.boolean;\n    case ReducerID.last:\n    case ReducerID.lastNotNull:\n    case ReducerID.first:\n    case ReducerID.firstNotNull:\n      return sourceField.type;\n    default:\n      return guessFieldTypeForField(targetField) ?? FieldType.string;\n  }\n};\n\n/**\n * Group values into subframes so that they'll be displayed\n * inside of a subtable.\n *\n * @param valuesByGroupKey\n *  A mapping of group keys to their respective grouped values.\n * @param options\n *   Transformation options, which are used to find ungrouped/unaggregated fields.\n * @returns\n */\nfunction groupToSubframes(\n  valuesByGroupKey: Map<string, FieldMap>,\n  options: GroupToNestedTableTransformerOptions\n): DataFrame[][] {\n  const subFrames: DataFrame[][] = [];\n\n  // Construct a subframe of any fields\n  // that aren't being group on or reduced\n  for (const [, value] of valuesByGroupKey) {\n    const nestedFields: Field[] = [];\n\n    for (const [fieldName, field] of Object.entries(value)) {\n      const fieldOpts = options.fields[fieldName];\n\n      if (fieldOpts === undefined) {\n        nestedFields.push(field);\n      }\n      // Depending on the configuration form state all of the following are possible\n      else if (\n        fieldOpts.aggregations === undefined ||\n        (fieldOpts.operation === GroupByOperationID.aggregate && fieldOpts.aggregations.length === 0) ||\n        fieldOpts.operation === null ||\n        fieldOpts.operation === undefined\n      ) {\n        nestedFields.push(field);\n      }\n    }\n\n    // If there are any values in the subfields\n    // push a new subframe with the fields\n    // otherwise push an empty frame\n    if (nestedFields.length > 0) {\n      subFrames.push([createSubframe(nestedFields, nestedFields[0].values.length, options)]);\n    } else {\n      subFrames.push([createSubframe([], 0, options)]);\n    }\n  }\n\n  return subFrames;\n}\n"],"names":[],"mappings":"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"}