{"version":3,"file":"AppendedVectors.js","sources":["../../../src/vector/AppendedVectors.ts"],"sourcesContent":["import { Vector, makeArrayIndexableVector } from '../types/vector';\n\nimport { FunctionalVector } from './FunctionalVector';\nimport { vectorToArray } from './vectorToArray';\n\ninterface AppendedVectorInfo<T> {\n  start: number;\n  end: number;\n  values: Vector<T>;\n}\n\n/**\n * This may be more trouble than it is worth.  This trades some computation time for\n * RAM -- rather than allocate a new array the size of all previous arrays, this just\n * points the correct index to their original array values\n *\n * @deprecated use a simple Arrays.  NOTE this is not used in grafana core\n */\nexport class AppendedVectors<T = any> extends FunctionalVector<T> {\n  length = 0;\n  source: Array<AppendedVectorInfo<T>> = [];\n\n  constructor(startAt = 0) {\n    super();\n    this.length = startAt;\n    return makeArrayIndexableVector(this);\n  }\n\n  /**\n   * Make the vector look like it is this long\n   */\n  setLength(length: number) {\n    if (length > this.length) {\n      // make the vector longer (filling with undefined)\n      this.length = length;\n    } else if (length < this.length) {\n      // make the array shorter\n      const sources: Array<AppendedVectorInfo<T>> = [];\n      for (const src of this.source) {\n        sources.push(src);\n        if (src.end > length) {\n          src.end = length;\n          break;\n        }\n      }\n      this.source = sources;\n      this.length = length;\n    }\n  }\n\n  append(v: Vector<T>): AppendedVectorInfo<T> {\n    const info = {\n      start: this.length,\n      end: this.length + v.length,\n      values: v,\n    };\n    this.length = info.end;\n    this.source.push(info);\n    return info;\n  }\n\n  get(index: number): T {\n    for (let i = 0; i < this.source.length; i++) {\n      const src = this.source[i];\n      if (index >= src.start && index < src.end) {\n        return src.values[index - src.start];\n      }\n    }\n    return undefined as unknown as T;\n  }\n\n  toArray(): T[] {\n    return vectorToArray(this);\n  }\n\n  toJSON(): T[] {\n    return vectorToArray(this);\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;AAkBO,MAAM,wBAAiC,gBAAoB,CAAA;AAAA,EAIhE,WAAA,CAAY,UAAU,CAAG,EAAA;AACvB,IAAM,KAAA,EAAA,CAAA;AAJR,IAAS,aAAA,CAAA,IAAA,EAAA,QAAA,EAAA,CAAA,CAAA,CAAA;AACT,IAAA,aAAA,CAAA,IAAA,EAAA,QAAA,EAAuC,EAAC,CAAA,CAAA;AAItC,IAAA,IAAA,CAAK,MAAS,GAAA,OAAA,CAAA;AACd,IAAA,OAAO,yBAAyB,IAAI,CAAA,CAAA;AAAA,GACtC;AAAA;AAAA;AAAA;AAAA,EAKA,UAAU,MAAgB,EAAA;AACxB,IAAI,IAAA,MAAA,GAAS,KAAK,MAAQ,EAAA;AAExB,MAAA,IAAA,CAAK,MAAS,GAAA,MAAA,CAAA;AAAA,KAChB,MAAA,IAAW,MAAS,GAAA,IAAA,CAAK,MAAQ,EAAA;AAE/B,MAAA,MAAM,UAAwC,EAAC,CAAA;AAC/C,MAAW,KAAA,MAAA,GAAA,IAAO,KAAK,MAAQ,EAAA;AAC7B,QAAA,OAAA,CAAQ,KAAK,GAAG,CAAA,CAAA;AAChB,QAAI,IAAA,GAAA,CAAI,MAAM,MAAQ,EAAA;AACpB,UAAA,GAAA,CAAI,GAAM,GAAA,MAAA,CAAA;AACV,UAAA,MAAA;AAAA,SACF;AAAA,OACF;AACA,MAAA,IAAA,CAAK,MAAS,GAAA,OAAA,CAAA;AACd,MAAA,IAAA,CAAK,MAAS,GAAA,MAAA,CAAA;AAAA,KAChB;AAAA,GACF;AAAA,EAEA,OAAO,CAAqC,EAAA;AAC1C,IAAA,MAAM,IAAO,GAAA;AAAA,MACX,OAAO,IAAK,CAAA,MAAA;AAAA,MACZ,GAAA,EAAK,IAAK,CAAA,MAAA,GAAS,CAAE,CAAA,MAAA;AAAA,MACrB,MAAQ,EAAA,CAAA;AAAA,KACV,CAAA;AACA,IAAA,IAAA,CAAK,SAAS,IAAK,CAAA,GAAA,CAAA;AACnB,IAAK,IAAA,CAAA,MAAA,CAAO,KAAK,IAAI,CAAA,CAAA;AACrB,IAAO,OAAA,IAAA,CAAA;AAAA,GACT;AAAA,EAEA,IAAI,KAAkB,EAAA;AACpB,IAAA,KAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,IAAK,CAAA,MAAA,CAAO,QAAQ,CAAK,EAAA,EAAA;AAC3C,MAAM,MAAA,GAAA,GAAM,IAAK,CAAA,MAAA,CAAO,CAAC,CAAA,CAAA;AACzB,MAAA,IAAI,KAAS,IAAA,GAAA,CAAI,KAAS,IAAA,KAAA,GAAQ,IAAI,GAAK,EAAA;AACzC,QAAA,OAAO,GAAI,CAAA,MAAA,CAAO,KAAQ,GAAA,GAAA,CAAI,KAAK,CAAA,CAAA;AAAA,OACrC;AAAA,KACF;AACA,IAAO,OAAA,KAAA,CAAA,CAAA;AAAA,GACT;AAAA,EAEA,OAAe,GAAA;AACb,IAAA,OAAO,cAAc,IAAI,CAAA,CAAA;AAAA,GAC3B;AAAA,EAEA,MAAc,GAAA;AACZ,IAAA,OAAO,cAAc,IAAI,CAAA,CAAA;AAAA,GAC3B;AACF;;;;"}