{"version":3,"file":"utils.js","sources":["../../../../src/components/uPlot/utils.ts"],"sourcesContent":["import uPlot, { AlignedData, Options, PaddingSide } from 'uplot';\n\nimport { DataFrame, ensureTimeField, FieldType } from '@grafana/data';\nimport { BarAlignment, GraphDrawStyle, GraphTransform, LineInterpolation, StackingMode } from '@grafana/schema';\n\nimport { attachDebugger } from '../../utils';\nimport { createLogger } from '../../utils/logger';\n\nimport { buildScaleKey } from './internal';\n\nconst ALLOWED_FORMAT_STRINGS_REGEX = /\\b(YYYY|YY|MMMM|MMM|MM|M|DD|D|WWWW|WWW|HH|H|h|AA|aa|a|mm|m|ss|s|fff)\\b/g;\n\nexport function timeFormatToTemplate(f: string) {\n  return f.replace(ALLOWED_FORMAT_STRINGS_REGEX, (match) => `{${match}}`);\n}\n\nconst paddingSide: PaddingSide = (u, side, sidesWithAxes) => {\n  let hasCrossAxis = side % 2 ? sidesWithAxes[0] || sidesWithAxes[2] : sidesWithAxes[1] || sidesWithAxes[3];\n\n  return sidesWithAxes[side] || !hasCrossAxis ? 0 : 8;\n};\n\nexport const DEFAULT_PLOT_CONFIG: Partial<Options> = {\n  ms: 1,\n  focus: {\n    alpha: 1,\n  },\n  cursor: {\n    focus: {\n      prox: 30,\n    },\n  },\n  legend: {\n    show: false,\n  },\n  padding: [paddingSide, paddingSide, paddingSide, paddingSide],\n  series: [],\n  hooks: {},\n};\n\n/** @internal */\ninterface StackMeta {\n  totals: AlignedData;\n}\n\n/** @internal */\nexport interface StackingGroup {\n  series: number[];\n  dir: StackDirection;\n}\n\n/** @internal */\nconst enum StackDirection {\n  Pos = 1,\n  Neg = -1,\n}\n\n// generates bands between adjacent group series\n/** @internal */\nexport function getStackingBands(group: StackingGroup) {\n  let bands: uPlot.Band[] = [];\n  let { series, dir } = group;\n  let lastIdx = series.length - 1;\n\n  let rSeries = series.slice().reverse();\n\n  rSeries.forEach((si, i) => {\n    if (i !== lastIdx) {\n      let nextIdx = rSeries[i + 1];\n      bands.push({\n        series: [si, nextIdx],\n        // fill direction is inverted from stack direction\n        dir: (-1 * dir) as 1 | -1,\n      });\n    }\n  });\n\n  return bands;\n}\n\n// expects an AlignedFrame\n/** @internal */\nexport function getStackingGroups(frame: DataFrame) {\n  let groups: Map<string, StackingGroup> = new Map();\n\n  frame.fields.forEach(({ config, values, type }, i) => {\n    // skip x or time field\n    if (i === 0) {\n      return;\n    }\n\n    let { custom } = config;\n\n    if (custom == null) {\n      return;\n    }\n\n    // TODO: currently all AlignedFrame fields end up in uplot series & data, even custom.hideFrom?.viz\n    // ideally hideFrom.viz fields would be excluded so we can remove this\n    if (custom.hideFrom?.viz) {\n      return;\n    }\n\n    let { stacking } = custom;\n\n    if (stacking == null) {\n      return;\n    }\n\n    let { mode: stackingMode, group: stackingGroup } = stacking;\n\n    // not stacking\n    if (stackingMode === StackingMode.None) {\n      return;\n    }\n\n    // will this be stacked up or down after any transforms applied\n    let transform = custom.transform;\n    let stackDir = getStackDirection(transform, values);\n\n    let drawStyle: GraphDrawStyle = custom.drawStyle;\n    let drawStyle2: BarAlignment | LineInterpolation | null =\n      drawStyle === GraphDrawStyle.Bars\n        ? custom.barAlignment\n        : drawStyle === GraphDrawStyle.Line\n          ? custom.lineInterpolation\n          : null;\n\n    let stackKey = `${stackDir}|${stackingMode}|${stackingGroup}|${buildScaleKey(\n      config,\n      type\n    )}|${drawStyle}|${drawStyle2}`;\n\n    let group = groups.get(stackKey);\n\n    if (group == null) {\n      group = {\n        series: [],\n        dir: stackDir,\n      };\n\n      groups.set(stackKey, group);\n    }\n\n    group.series.push(i);\n  });\n\n  return [...groups.values()];\n}\n\n/** @internal */\nexport function preparePlotData2(\n  frame: DataFrame,\n  stackingGroups: StackingGroup[],\n  onStackMeta?: (meta: StackMeta) => void\n) {\n  let data: AlignedData = Array(frame.fields.length);\n\n  let stacksQty = stackingGroups.length;\n\n  let dataLen = frame.length;\n  let zeroArr = stacksQty > 0 ? Array(dataLen).fill(0) : [];\n  let falseArr = stacksQty > 0 ? Array(dataLen).fill(false) : [];\n  let accums = Array.from({ length: stacksQty }, () => zeroArr.slice());\n\n  let anyValsAtX = Array.from({ length: stacksQty }, () => falseArr.slice());\n\n  // figure out at which time indices each stacking group has any values\n  // (needed to avoid absorbing initial accum 0s at unrelated joined timestamps)\n  stackingGroups.forEach((group, groupIdx) => {\n    let groupValsAtX = anyValsAtX[groupIdx];\n\n    group.series.forEach((seriesIdx) => {\n      let field = frame.fields[seriesIdx];\n\n      if (field.config.custom?.hideFrom?.viz) {\n        return;\n      }\n\n      let vals = field.values;\n\n      for (let i = 0; i < dataLen; i++) {\n        if (vals[i] != null) {\n          groupValsAtX[i] = true;\n        }\n      }\n    });\n  });\n\n  frame.fields.forEach((field, i) => {\n    let vals = field.values;\n\n    if (i === 0) {\n      if (field.type === FieldType.time) {\n        data[i] = ensureTimeField(field).values;\n      } else {\n        data[i] = vals;\n      }\n      return;\n    }\n\n    let { custom } = field.config;\n\n    if (!custom || custom.hideFrom?.viz) {\n      data[i] = vals;\n      return;\n    }\n\n    // apply transforms\n    if (custom.transform === GraphTransform.Constant) {\n      let firstValIdx = vals.findIndex((v) => v != null);\n      let firstVal = vals[firstValIdx];\n      vals = Array(vals.length).fill(undefined);\n      vals[firstValIdx] = firstVal;\n    } else {\n      vals = vals.slice();\n\n      if (custom.transform === GraphTransform.NegativeY) {\n        for (let i = 0; i < vals.length; i++) {\n          if (vals[i] != null) {\n            vals[i] *= -1;\n          }\n        }\n      }\n    }\n\n    let stackingMode = custom.stacking?.mode;\n\n    if (!stackingMode || stackingMode === StackingMode.None) {\n      data[i] = vals;\n    } else {\n      let stackIdx = stackingGroups.findIndex((group) => group.series.indexOf(i) > -1);\n\n      let accum = accums[stackIdx];\n      let groupValsAtX = anyValsAtX[stackIdx];\n      let stacked = (data[i] = Array(dataLen));\n\n      for (let i = 0; i < dataLen; i++) {\n        let v = vals[i];\n\n        if (v != null) {\n          stacked[i] = accum[i] += v;\n        } else {\n          stacked[i] = groupValsAtX[i] ? accum[i] : v;\n        }\n      }\n    }\n  });\n\n  if (onStackMeta) {\n    let accumsBySeriesIdx = data.map((vals, i) => {\n      let stackIdx = stackingGroups.findIndex((group) => group.series.indexOf(i) > -1);\n      return stackIdx !== -1 ? accums[stackIdx] : vals;\n    });\n\n    onStackMeta({\n      totals: accumsBySeriesIdx as AlignedData,\n    });\n  }\n\n  // re-compute by percent\n  frame.fields.forEach((field, i) => {\n    if (i === 0 || field.config.custom?.hideFrom?.viz) {\n      return;\n    }\n\n    let stackingMode = field.config.custom?.stacking?.mode;\n\n    if (stackingMode === StackingMode.Percent) {\n      let stackIdx = stackingGroups.findIndex((group) => group.series.indexOf(i) > -1);\n      let accum = accums[stackIdx];\n      let group = stackingGroups[stackIdx];\n\n      let stacked = data[i];\n\n      for (let i = 0; i < dataLen; i++) {\n        let v = stacked[i];\n\n        if (v != null) {\n          // v / accum will always be pos, so properly (re)sign by group stacking dir\n          stacked[i] = accum[i] === 0 ? 0 : group.dir * (v / accum[i]);\n        }\n      }\n    }\n  });\n\n  return data;\n}\n\n/**\n * Finds y axis midpoint for point at given idx (css pixels relative to uPlot canvas)\n * @internal\n **/\n\nexport function findMidPointYPosition(u: uPlot, idx: number) {\n  let y;\n  let sMaxIdx = 1;\n  let sMinIdx = 1;\n  // assume min/max being values of 1st series\n  let max = u.data[1][idx];\n  let min = u.data[1][idx];\n\n  // find min max values AND ids of the corresponding series to get the scales\n  for (let i = 1; i < u.data.length; i++) {\n    const sData = u.data[i];\n    const sVal = sData[idx];\n    if (sVal != null) {\n      if (max == null) {\n        max = sVal;\n      } else {\n        if (sVal > max) {\n          max = u.data[i][idx];\n          sMaxIdx = i;\n        }\n      }\n      if (min == null) {\n        min = sVal;\n      } else {\n        if (sVal < min) {\n          min = u.data[i][idx];\n          sMinIdx = i;\n        }\n      }\n    }\n  }\n\n  if (min == null && max == null) {\n    // no tooltip to show\n    y = undefined;\n  } else if (min != null && max != null) {\n    // find median position\n    y = (u.valToPos(min, u.series[sMinIdx].scale!) + u.valToPos(max, u.series[sMaxIdx].scale!)) / 2;\n  } else {\n    // snap tooltip to min OR max point, one of those is not null :)\n    y = u.valToPos((min || max)!, u.series[(sMaxIdx || sMinIdx)!].scale!);\n  }\n\n  // if y is out of canvas bounds, snap it to the bottom\n  if (y !== undefined && y < 0) {\n    y = u.bbox.height / devicePixelRatio;\n  }\n\n  return y;\n}\n\nfunction getStackDirection(transform: GraphTransform, data: unknown[]) {\n  const hasNegSamp = hasNegSample(data);\n\n  if (transform === GraphTransform.NegativeY) {\n    return hasNegSamp ? StackDirection.Pos : StackDirection.Neg;\n  }\n  return hasNegSamp ? StackDirection.Neg : StackDirection.Pos;\n}\n\n// similar to isLikelyAscendingVector()\nfunction hasNegSample(data: unknown[], samples = 100) {\n  const len = data.length;\n\n  if (len === 0) {\n    return false;\n  }\n\n  // skip leading & trailing nullish\n  let firstIdx = 0;\n  let lastIdx = len - 1;\n\n  while (firstIdx <= lastIdx && data[firstIdx] == null) {\n    firstIdx++;\n  }\n\n  while (lastIdx >= firstIdx && data[lastIdx] == null) {\n    lastIdx--;\n  }\n\n  let negCount = 0;\n  let posCount = 0;\n\n  if (lastIdx >= firstIdx) {\n    const stride = Math.max(1, Math.floor((lastIdx - firstIdx + 1) / samples));\n\n    for (let i = firstIdx; i <= lastIdx; i += stride) {\n      const v = data[i];\n\n      if (v != null && typeof v === 'number') {\n        if (v < 0 || Object.is(v, -0)) {\n          negCount++;\n        } else if (v > 0) {\n          posCount++;\n        }\n      }\n    }\n\n    if (negCount > posCount) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Dev helpers\n\n/** @internal */\nexport const pluginLogger = createLogger('uPlot');\nexport const pluginLog = pluginLogger.logger;\n// pluginLogger.enable();\nattachDebugger('graphng', undefined, pluginLogger);\n"],"names":["i","group"],"mappings":"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"}