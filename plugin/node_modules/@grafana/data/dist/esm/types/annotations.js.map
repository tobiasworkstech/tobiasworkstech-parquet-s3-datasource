{"version":3,"file":"annotations.js","sources":["../../../src/types/annotations.ts"],"sourcesContent":["import { ComponentType } from 'react';\nimport { Observable } from 'rxjs';\n\nimport { AnnotationQuery as SchemaAnnotationQuery, DataQuery } from '@grafana/schema';\n\nimport { DataFrame } from './dataFrame';\nimport { QueryEditorProps } from './datasource';\n\n/**\n * This JSON object is stored in the dashboard json model.\n */\nexport interface AnnotationQuery<TQuery extends DataQuery = DataQuery> extends SchemaAnnotationQuery<TQuery> {\n  snapshotData?: any;\n\n  // Convert a dataframe to an AnnotationEvent\n  mappings?: AnnotationEventMappings;\n\n  // When using the 'grafana' datasource, this may be dashboard\n  type?: string;\n\n  // Sadly plugins can set any property directly on the main object\n  [key: string]: any;\n}\n\nexport interface AnnotationEvent {\n  id?: string;\n  annotation?: any;\n  dashboardId?: number;\n  dashboardUID?: string;\n  panelId?: number;\n  userId?: number;\n  login?: string;\n  email?: string;\n  avatarUrl?: string;\n  time?: number;\n  timeEnd?: number;\n  isRegion?: boolean;\n  title?: string;\n  text?: string;\n  type?: string;\n  tags?: string[];\n  color?: string;\n  alertId?: number;\n  newState?: string;\n\n  // Currently used to merge annotations from alerts and dashboard\n  source?: any; // source.type === 'dashboard' -- should be AnnotationQuery\n}\n\nexport interface AnnotationEventUIModel {\n  id?: string;\n  from: number;\n  to: number;\n  tags: string[];\n  description: string;\n}\n\n/**\n * @alpha -- any value other than `field` is experimental\n */\nexport enum AnnotationEventFieldSource {\n  Field = 'field', // Default -- find the value with a matching key\n  Text = 'text', // Write a constant string into the value\n  Skip = 'skip', // Do not include the field\n}\n\nexport interface AnnotationEventFieldMapping {\n  source?: AnnotationEventFieldSource; // defaults to 'field'\n  value?: string;\n  regex?: string;\n}\n\nexport type AnnotationEventMappings = Partial<Record<keyof AnnotationEvent, AnnotationEventFieldMapping>>;\ntype AnnotationQueryEditorProps<TQuery extends DataQuery> = QueryEditorProps<any, TQuery> & {\n  // Needs to be optional otherwise component not using these cannot be used, even though they are passed on and can be\n  // just ignored if not used.\n  annotation?: AnnotationQuery<TQuery>;\n  onAnnotationChange?: (annotation: AnnotationQuery<TQuery>) => void;\n};\n\n/**\n * Since Grafana 7.2\n *\n * This offers a generic approach to annotation processing\n */\nexport interface AnnotationSupport<TQuery extends DataQuery = DataQuery, TAnno = AnnotationQuery<TQuery>> {\n  /**\n   * This hook lets you manipulate any existing stored values before running them though the processor.\n   * This is particularly helpful when dealing with migrating old formats.  ie query as a string vs object.\n   */\n  prepareAnnotation?(json: any): TAnno;\n\n  /**\n   * Convert the stored JSON model to a standard datasource query object.\n   * This query will be executed in the datasource and the results converted into events.\n   * Returning an undefined result will quietly skip query execution\n   */\n  prepareQuery?(anno: TAnno): TQuery | undefined;\n\n  /**\n   * When the standard frame > event processing is insufficient, this allows explicit control of the mappings\n   */\n  processEvents?(anno: TAnno, data: DataFrame[]): Observable<AnnotationEvent[] | undefined>;\n\n  /**\n   * Specify a custom QueryEditor for the annotation page. If not specified, the standard one will be used\n   */\n  QueryEditor?: ComponentType<AnnotationQueryEditorProps<TQuery>>;\n\n  /**\n   * Define this method if you want to pre-populate the editor with a default query\n   */\n  getDefaultQuery?(): Partial<TQuery>;\n}\n"],"names":["AnnotationEventFieldSource"],"mappings":"AA4DY,IAAA,0BAAA,qBAAAA,2BAAL,KAAA;AACL,EAAAA,4BAAA,OAAQ,CAAA,GAAA,OAAA,CAAA;AACR,EAAAA,4BAAA,MAAO,CAAA,GAAA,MAAA,CAAA;AACP,EAAAA,4BAAA,MAAO,CAAA,GAAA,MAAA,CAAA;AAHG,EAAAA,OAAAA,2BAAAA,CAAAA;AAAA,CAAA,EAAA,0BAAA,IAAA,EAAA;;;;"}