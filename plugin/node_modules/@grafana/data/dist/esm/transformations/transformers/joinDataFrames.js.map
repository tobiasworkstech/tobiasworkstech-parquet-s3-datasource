{"version":3,"file":"joinDataFrames.js","sources":["../../../../src/transformations/transformers/joinDataFrames.ts"],"sourcesContent":["import intersect from 'fast_array_intersect';\n\nimport { getTimeField, sortDataFrame } from '../../dataframe';\nimport { DataFrame, Field, FieldMatcher, FieldType, TIME_SERIES_VALUE_FIELD_NAME } from '../../types';\nimport { fieldMatchers } from '../matchers';\nimport { FieldMatcherID } from '../matchers/ids';\n\nimport { JoinMode } from './joinByField';\n\nexport function pickBestJoinField(data: DataFrame[]): FieldMatcher {\n  const { timeField } = getTimeField(data[0]);\n  if (timeField) {\n    return fieldMatchers.get(FieldMatcherID.firstTimeField).get({});\n  }\n  let common: string[] = [];\n  for (const f of data[0].fields) {\n    if (f.type === FieldType.number) {\n      common.push(f.name);\n    }\n  }\n\n  for (let i = 1; i < data.length; i++) {\n    const names: string[] = [];\n    for (const f of data[0].fields) {\n      if (f.type === FieldType.number) {\n        names.push(f.name);\n      }\n    }\n    common = common.filter((v) => !names.includes(v));\n  }\n\n  return fieldMatchers.get(FieldMatcherID.byName).get(common[0]);\n}\n\n/**\n * @internal\n */\nexport interface JoinOptions {\n  /**\n   * The input fields\n   */\n  frames: DataFrame[];\n\n  /**\n   * The field to join -- frames that do not have this field will be dropped\n   */\n  joinBy?: FieldMatcher;\n\n  /**\n   * Optionally filter the non-join fields\n   */\n  keep?: FieldMatcher;\n\n  /**\n   * @internal -- used when we need to keep a reference to the original frame/field index\n   */\n  keepOriginIndices?: boolean;\n\n  /**\n   * @internal -- Optionally specify a join mode (outer or inner)\n   */\n  mode?: JoinMode;\n}\n\nfunction getJoinMatcher(options: JoinOptions): FieldMatcher {\n  return options.joinBy ?? pickBestJoinField(options.frames);\n}\n\n/**\n * @internal\n */\nexport function maybeSortFrame(frame: DataFrame, fieldIdx: number) {\n  if (fieldIdx >= 0) {\n    let sortByField = frame.fields[fieldIdx];\n\n    if (sortByField.type !== FieldType.string && !isLikelyAscendingVector(sortByField.values)) {\n      frame = sortDataFrame(frame, fieldIdx);\n    }\n  }\n\n  return frame;\n}\n\n/**\n * This will return a single frame joined by the first matching field.  When a join field is not specified,\n * the default will use the first time field\n */\nexport function joinDataFrames(options: JoinOptions): DataFrame | undefined {\n  if (!options.frames?.length) {\n    return;\n  }\n\n  if (options.frames.length === 1) {\n    let frame = options.frames[0];\n    let frameCopy = frame;\n\n    const joinFieldMatcher = getJoinMatcher(options);\n    let joinIndex = frameCopy.fields.findIndex((f) => joinFieldMatcher(f, frameCopy, options.frames));\n\n    if (options.keepOriginIndices) {\n      frameCopy = {\n        ...frame,\n        fields: frame.fields.map((f, fieldIndex) => {\n          const copy = { ...f };\n          const origin = {\n            frameIndex: 0,\n            fieldIndex,\n          };\n          if (copy.state) {\n            copy.state.origin = origin;\n          } else {\n            copy.state = { origin };\n          }\n          return copy;\n        }),\n      };\n\n      // Make sure the join field is first\n      if (joinIndex > 0) {\n        const joinField = frameCopy.fields[joinIndex];\n        const fields = frameCopy.fields.filter((f, idx) => idx !== joinIndex);\n        fields.unshift(joinField);\n        frameCopy.fields = fields;\n        joinIndex = 0;\n      }\n    }\n\n    if (joinIndex >= 0) {\n      frameCopy = maybeSortFrame(frameCopy, joinIndex);\n    }\n\n    if (options.keep) {\n      let fields = frameCopy.fields.filter(\n        (f, fieldIdx) => fieldIdx === joinIndex || options.keep!(f, frameCopy, options.frames)\n      );\n\n      // mutate already copied frame\n      if (frame !== frameCopy) {\n        frameCopy.fields = fields;\n      } else {\n        frameCopy = {\n          ...frame,\n          fields,\n        };\n      }\n    }\n\n    return frameCopy;\n  }\n\n  const nullModes: JoinNullMode[][] = [];\n  const allData: AlignedData[] = [];\n  const originalFields: Field[] = [];\n  // store frame field order for tabular data join\n  const originalFieldsOrderByFrame: number[][] = [];\n  // all other fields that are not the join on are in the 1+ position (join is always the 0)\n  let fieldsOrder = 1;\n  const joinFieldMatcher = getJoinMatcher(options);\n\n  for (let frameIndex = 0; frameIndex < options.frames.length; frameIndex++) {\n    const frame = options.frames[frameIndex];\n\n    if (!frame || !frame.fields?.length) {\n      continue; // skip the frame\n    }\n\n    const nullModesFrame: JoinNullMode[] = [NULL_REMOVE];\n    let join: Field | undefined = undefined;\n    let fields: Field[] = [];\n    let frameFieldsOrder = [];\n\n    for (let fieldIndex = 0; fieldIndex < frame.fields.length; fieldIndex++) {\n      const field = frame.fields[fieldIndex];\n      field.state = field.state || {};\n\n      if (!join && joinFieldMatcher(field, frame, options.frames)) {\n        join = field;\n      } else {\n        if (options.keep && !options.keep(field, frame, options.frames)) {\n          continue; // skip field\n        }\n\n        // Support the standard graph span nulls field config\n        let spanNulls = field.config.custom?.spanNulls;\n        nullModesFrame.push(spanNulls === true ? NULL_REMOVE : spanNulls === -1 ? NULL_RETAIN : NULL_EXPAND);\n\n        let labels = field.labels ?? {};\n        let name = field.name;\n        if (frame.name) {\n          if (field.name === TIME_SERIES_VALUE_FIELD_NAME) {\n            name = frame.name;\n          } else {\n            labels = { ...labels, name: frame.name };\n          }\n        }\n\n        fields.push({\n          ...field,\n          name,\n          labels, // add the name label from frame\n        });\n      }\n\n      if (options.keepOriginIndices) {\n        field.state.origin = {\n          frameIndex,\n          fieldIndex,\n        };\n      }\n    }\n\n    if (!join) {\n      continue; // skip the frame\n    }\n\n    if (originalFields.length === 0) {\n      originalFields.push(join); // first join field\n    }\n\n    nullModes.push(nullModesFrame);\n    const a: AlignedData = [join.values]; //\n\n    for (const field of fields) {\n      a.push(field.values);\n      originalFields.push(field);\n      // clear field displayName state\n      delete field.state?.displayName;\n      // store frame field order for tabular data join\n      frameFieldsOrder.push(fieldsOrder);\n      fieldsOrder++;\n    }\n    // store frame field order for tabular data join\n    originalFieldsOrderByFrame.push(frameFieldsOrder);\n    allData.push(a);\n  }\n\n  let joined: Array<Array<number | string | null | undefined>> = [];\n\n  if (options.mode === JoinMode.outerTabular) {\n    joined = joinOuterTabular(allData, originalFieldsOrderByFrame, originalFields.length, nullModes);\n  } else {\n    joined = join(allData, nullModes, options.mode);\n  }\n\n  return {\n    // ...options.data[0], // keep name, meta?\n    length: joined[0] ? joined[0].length : 0,\n    fields: originalFields.map((f, index) => ({\n      ...f,\n      values: joined[index],\n    })),\n  };\n}\n\n// The following full outer join allows for multiple/duplicated joined fields values where as the performant join from uplot creates a unique set of field values to be joined on\n// http://www.silota.com/docs/recipes/sql-join-tutorial-javascript-examples.html\n// The frame field value which is used join on is sorted to the 0 position of each table data in both tables and nullModes\n// (not sure if we need nullModes) for nullModes, the field to join on is given NULL_REMOVE and all other fields are given NULL_EXPAND\nfunction joinOuterTabular(\n  tables: AlignedData[],\n  originalFieldsOrderByFrame: number[][],\n  numberOfFields: number,\n  nullModes?: number[][]\n) {\n  // we will iterate through all frames and check frames for matches preventing duplicates.\n  // we will store each matched frame \"row\" or field values at the same index in the following hash.\n  let duplicateHash: { [key: string]: Array<number | string | null | undefined> } = {};\n\n  // iterate through the tables (frames)\n  // for each frame we get the field data where the data in the 0 pos is the value to join on\n  for (let tableIdx = 0; tableIdx < tables.length; tableIdx++) {\n    // the table (frame) to check for matches in other tables\n    let table = tables[tableIdx];\n    // the field value to join on (the join value is always in the 0 position)\n    let joinOnTableField = table[0];\n\n    // now we iterate through the other table (frame) data to look for matches\n    for (let otherTablesIdx = 0; otherTablesIdx < tables.length; otherTablesIdx++) {\n      // do not match on the same table\n      if (otherTablesIdx === tableIdx) {\n        continue;\n      }\n\n      let otherTable = tables[otherTablesIdx];\n      let otherTableJoinOnField = otherTable[0];\n\n      // iterate through the field to join on from the first table\n      for (\n        let joinTableFieldValuesIdx = 0;\n        joinTableFieldValuesIdx < joinOnTableField.length;\n        joinTableFieldValuesIdx++\n      ) {\n        // create the joined data\n        // this has the orignalFields length and should start out undefined\n        // joined row + number of other fields in each frame\n        // the order of each field is important in how we\n        // 1 check for duplicates\n        // 2 transform the row back into fields for the joined frame\n        // 3 when there is no match for the row we keep the vals undefined\n        const tableJoinOnValue = joinOnTableField[joinTableFieldValuesIdx];\n        const allOtherFields = numberOfFields - 1;\n        let joinedRow: Array<number | string | null | undefined> = [tableJoinOnValue].concat(new Array(allOtherFields));\n\n        let tableFieldValIdx = 0;\n        for (let fieldsIdx = 1; fieldsIdx < table.length; fieldsIdx++) {\n          const joinRowIdx = originalFieldsOrderByFrame[tableIdx][tableFieldValIdx];\n          joinedRow[joinRowIdx] = table[fieldsIdx][joinTableFieldValuesIdx];\n          tableFieldValIdx++;\n        }\n\n        for (let otherTableValuesIdx = 0; otherTableValuesIdx < otherTableJoinOnField.length; otherTableValuesIdx++) {\n          if (joinOnTableField[joinTableFieldValuesIdx] === otherTableJoinOnField[otherTableValuesIdx]) {\n            let tableFieldValIdx = 0;\n            for (let fieldsIdx = 1; fieldsIdx < otherTable.length; fieldsIdx++) {\n              const joinRowIdx = originalFieldsOrderByFrame[otherTablesIdx][tableFieldValIdx];\n              joinedRow[joinRowIdx] = otherTable[fieldsIdx][otherTableValuesIdx];\n              tableFieldValIdx++;\n            }\n\n            break;\n          }\n        }\n\n        // prevent duplicates by entering rows in a hash where keys are the rows\n        duplicateHash[JSON.stringify(joinedRow)] = joinedRow;\n      }\n    }\n  }\n\n  // transform the joined rows into data for a dataframe\n  let data: Array<Array<number | string | null | undefined>> = [];\n  for (let field = 0; field < numberOfFields; field++) {\n    data.push(new Array(0));\n  }\n\n  for (let key in duplicateHash) {\n    const row = duplicateHash[key];\n\n    for (let valIdx = 0; valIdx < row.length; valIdx++) {\n      data[valIdx].push(row[valIdx]);\n    }\n  }\n\n  return data;\n}\n\n//--------------------------------------------------------------------------------\n// Below here is copied from uplot (MIT License)\n// https://github.com/leeoniya/uPlot/blob/master/src/utils.js#L325\n// This avoids needing to import uplot into the data package\n//--------------------------------------------------------------------------------\n\n// Copied from uplot\nexport type TypedArray =\n  | Int8Array\n  | Uint8Array\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Uint8ClampedArray\n  | Float32Array\n  | Float64Array;\n\nexport type AlignedData =\n  | TypedArray[]\n  | [xValues: number[] | TypedArray, ...yValues: Array<Array<number | null | undefined> | TypedArray>];\n\n// nullModes\nconst NULL_REMOVE = 0; // nulls are converted to undefined (e.g. for spanGaps: true)\nconst NULL_RETAIN = 1; // nulls are retained, with alignment artifacts set to undefined (default)\nconst NULL_EXPAND = 2; // nulls are expanded to include any adjacent alignment artifacts\n\ntype JoinNullMode = number; // NULL_IGNORE | NULL_RETAIN | NULL_EXPAND;\n\n// sets undefined values to nulls when adjacent to existing nulls (minesweeper)\nfunction nullExpand(yVals: Array<number | null>, nullIdxs: number[], alignedLen: number) {\n  for (let i = 0, xi, lastNullIdx = -1; i < nullIdxs.length; i++) {\n    let nullIdx = nullIdxs[i];\n\n    if (nullIdx > lastNullIdx) {\n      xi = nullIdx - 1;\n      while (xi >= 0 && yVals[xi] == null) {\n        yVals[xi--] = null;\n      }\n\n      xi = nullIdx + 1;\n      while (xi < alignedLen && yVals[xi] == null) {\n        yVals[(lastNullIdx = xi++)] = null;\n      }\n    }\n  }\n}\n\n// nullModes is a tables-matched array indicating how to treat nulls in each series\nexport function join(tables: AlignedData[], nullModes?: number[][], mode: JoinMode = JoinMode.outer) {\n  let xVals: Set<number>;\n\n  if (mode === JoinMode.inner) {\n    // @ts-ignore\n    xVals = new Set(intersect(tables.map((t) => t[0])));\n  } else {\n    xVals = new Set();\n\n    for (let ti = 0; ti < tables.length; ti++) {\n      let t = tables[ti];\n      let xs = t[0];\n      let len = xs.length;\n\n      for (let i = 0; i < len; i++) {\n        xVals.add(xs[i]);\n      }\n    }\n  }\n\n  let data = [Array.from(xVals).sort((a, b) => a - b)];\n\n  let alignedLen = data[0].length;\n\n  let xIdxs = new Map();\n\n  for (let i = 0; i < alignedLen; i++) {\n    xIdxs.set(data[0][i], i);\n  }\n\n  for (let ti = 0; ti < tables.length; ti++) {\n    let t = tables[ti];\n    let xs = t[0];\n\n    for (let si = 1; si < t.length; si++) {\n      let ys = t[si];\n\n      let yVals = Array(alignedLen).fill(undefined);\n\n      let nullMode = nullModes ? nullModes[ti][si] : NULL_RETAIN;\n\n      let nullIdxs = [];\n\n      for (let i = 0; i < ys.length; i++) {\n        let yVal = ys[i];\n        let alignedIdx = xIdxs.get(xs[i]);\n\n        if (yVal === null) {\n          if (nullMode !== NULL_REMOVE) {\n            yVals[alignedIdx] = yVal;\n\n            if (nullMode === NULL_EXPAND) {\n              nullIdxs.push(alignedIdx);\n            }\n          }\n        } else {\n          yVals[alignedIdx] = yVal;\n        }\n      }\n\n      nullExpand(yVals, nullIdxs, alignedLen);\n\n      data.push(yVals);\n    }\n  }\n\n  return data;\n}\n\n// Test a few samples to see if the values are ascending\n// Only exported for tests\nexport function isLikelyAscendingVector(data: any[], samples = 50) {\n  const len = data.length;\n\n  // empty or single value\n  if (len <= 1) {\n    return true;\n  }\n\n  // skip leading & trailing nullish\n  let firstIdx = 0;\n  let lastIdx = len - 1;\n\n  while (firstIdx <= lastIdx && data[firstIdx] == null) {\n    firstIdx++;\n  }\n\n  while (lastIdx >= firstIdx && data[lastIdx] == null) {\n    lastIdx--;\n  }\n\n  // all nullish or one value surrounded by nullish\n  if (lastIdx <= firstIdx) {\n    return true;\n  }\n\n  const stride = Math.max(1, Math.floor((lastIdx - firstIdx + 1) / samples));\n\n  for (let prevVal = data[firstIdx], i = firstIdx + stride; i <= lastIdx; i += stride) {\n    const v = data[i];\n\n    if (v != null) {\n      if (v <= prevVal) {\n        return false;\n      }\n\n      prevVal = v;\n    }\n  }\n\n  return true;\n}\n"],"names":["joinFieldMatcher","join","tableFieldValIdx"],"mappings":"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"}